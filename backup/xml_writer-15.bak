import xml.etree.ElementTree as ET
import d_contents as data
import colors
from pathlib import Path

color_directory_background = '#0083d5'
color_directory_light = '#12c5ff'
color_directory_dark = '#1075f6'
color_glyph_light = '#126c98'
color_glyph_dark = '#0b4f94'

id_gradient_directory = 'directory-gradient'
id_gradient_glyph = 'glyph-gradient'

DEFAULT_TRANSFORM_VALUE = 'scale(.75)'
DEFAULT_GLYPH_GRADIENT_TRANSFORM = 'matrix(1.77928e-15,29.0579,-29.0579,1.77928e-15,-583.701,19.4233)'

def normalized_svg_file(file: Path) -> Path:
    if not file.name.endswith('.svg'):
        stringfied = str(file)
        stringfied += '.svg'
        file = Path(stringfied)
    
    return file

def normalize_hex_value(color_hex: str) -> str | None:
    # evitar possíveis valores nulos, pq hex deve sempre ser string
    # se não for, é melhor deixar claro que é um valor inválido
    if not isinstance(color_hex, str):
        return None
    
    # adiciona # na frente do valor hex se ele já não tiver
    if not color_hex.startswith('#'):
        color_hex = f'#{color_hex}'
    
    # se tiver mais de 7 dígitos no hex (contando com a # no começo)
    # obtendo apenas do índice 0 até o 7, removendo os últimos 2 (ou mais) dígitos que indicam a opacidade da cor
    # a opacidade pode fazer a cor quebrar no svg se estiver presente. ela deve ser definida com fill-opacity
    if len(color_hex) > 7:
        color_hex = color_hex[:7]

    return color_hex

def draw_directory(
    svg: ET.Element,
    back_fill: str,
    front_fill: str,
    group_id: str = 'directory-group'
    ):
    group = ET.SubElement(svg, 'g', {
        'id': group_id,
        'transform': 'scale(.75)'
    })

    # background do diretório, um retangulo com cor sólida
    ET.SubElement(group, 'path', {
        'd': 'm61.122 15.88c0-2.762-2.239-5-5-5h-48.244c-2.761 0-5 2.238-5 5v32.246c0 2.761 2.239 5 5 5h48.244c2.761 0 5-2.239 5-5v-32.246z',
        'style': f'fill:{back_fill}; fill-opacity:1',
    })

    # parte da frente do diretório, com curvas e gradiente
    ET.SubElement(group, 'path', {
        'd': 'm61.122 20.652c0-1.326-0.527-2.598-1.465-3.536-0.938-0.937-2.209-1.464-3.535-1.464h-25.58c-1.232 0-2.42-0.455-3.337-1.277-0.768-0.689-1.713-1.535-2.481-2.224-0.917-0.822-2.105-1.277-3.337-1.277h-13.509c-1.326 0-2.597 0.527-3.535 1.465-0.938 0.937-1.465 2.209-1.465 3.535v32.252c0 2.761 2.239 5 5 5h48.244c2.761 0 5-2.239 5-5v-27.474z',
        'style': f'fill:{front_fill}; fill-opacity:1'
    })

def draw_glyph(
    svg: ET.Element,
    d_contents: str,
    fill: str,
    group_id:str = 'glyph-group',
    requires_scale: bool = True,
    transform_value: str = DEFAULT_TRANSFORM_VALUE,
    gradient_transform: str = DEFAULT_GLYPH_GRADIENT_TRANSFORM
    ):
    """
    desenha um glifo em um grupo, que deve ser posto em cima do ícone de diretório vazio
    pra isso acontecer, deve se chamar essa função APÓS a draw_directory()

    args:
        svg:
            o elemento svg principal a qual o grupo gerado por essa função deve ser adicionado
        
        d_contents:
            dados que formam o desenho do glifo, presentes no <path> que o define
        
        gradient_id:
            gradiente a ser usado pra colorir o glifo. deve ter sido definido antes de ser passado

        group_id:
            nome/id que o grupo gerado por essa função vai ter

        requires_scale:
            define se o glifo que vai ser desenhado precisa de alguma transformação especial
            alguns glifos precisam, se não ficam muito pequenos, enquanto outros não precisam, se não ficam muito grandes
            na maioria das vezes, scale(.75) já resolve, mas pode haver situações que um transform customizado deve ser passado
            o jeito de saber quais precisam ou não é gerar os svgs com todos os glifos e olhar manualmente
        
        transform_value:
            o valor customizado pra um transform. se não for passado, assume que a transformação deve usar scale(.75)
            
            pra saber o transform apropriado pra um glifo problemático, olha o conteúdo de texto do svg original do kora
            lá vai ter algo como:
            <g
                transform="matrix(1.32032,0,0,1.17497,-11.3269,-6.98679)" <- esse valor é o que deve ser usado
                id=...>
                
                <path
                    d=...
                    style=...
                    id=...
                />
            </g>

            se o transform não estiver presente ou for simplesmente scale(0.75), não precisa passar nada pra esse argumento
    """
    
    # os atributos aqui são definidos separadamente pra poder aplicar a scale só se necessário
    attributes = {
        'id': group_id,
        #'transform': 'scale(.75)'
    }
    if requires_scale:
        attributes['transform'] = transform_value
    
    group = ET.SubElement(svg, 'g', attributes)

    ET.SubElement(group, 'path', {
        'd': d_contents,
        'style': f'fill:{fill}; fill-opacity:1'
    })

def handle_fill(
    hex_map: dict,
    defs: ET.SubElement,
    gradient_id: str,
    gradient_transform: str | None = None,
    gradient_units: str = 'userSpaceOnUse', # faz o gradiente ser relativo ao tamanho do documento
    first_stop_offset: float = 0, # controlam onde cadas top fica
    second_stop_offset: float = 1
    ):
    top = hex_map.get('top')
    bottom = hex_map.get('bottom')

    top = normalize_hex_value(top)
    bottom = normalize_hex_value(bottom)

    fill = None
    if top and bottom:
        first_stop_offset = str(first_stop_offset)
        second_stop_offset = str(second_stop_offset)

        attributes = {
            'id': gradient_id,
            'x2': '1',
            'gradientUnits': gradient_units
        }
        if gradient_transform is not None:
            attributes['gradientTransform'] = gradient_transform

        gradient = ET.SubElement(defs, 'linearGradient', attributes)
        ET.SubElement(gradient, 'stop', {
            'style': f'stop-color:{top}',
            'offset': first_stop_offset
        })
        ET.SubElement(gradient, 'stop', {
            'style': f'stop-color:{bottom}',
            'offset': second_stop_offset
        })

        fill = f'url(#{gradient_id})'
    elif top:
        fill = top
    elif bottom:
        fill = bottom

    return fill

def structure_svg(
    output_file: Path,
    hex_front: dict,
    hex_back: dict,
    hex_glyph: dict,
    glyph_d_contents: str | None = None,
    glyph_requires_scale: bool = True,
    glyph_transform_value: str = DEFAULT_TRANSFORM_VALUE,
    glyph_gradient_transform: str = DEFAULT_GLYPH_GRADIENT_TRANSFORM
    ):
    """

    """
    
    # elemento <svg> principal que contém todo o conteúdo
    # todo elemento (exceto o <xml>, se presente) deve ser um subelemento daqui
    #
    # esses valores nele são o que geralmente já tem no ícone base de diretório do kora
    # ex: <svg style=x viewBox=y xmlns=z</svg>
    svg = ET.Element('svg', {
        'xmlns': 'http://www.w3.org/2000/svg',
        'viewBox': '0 0 48 48',
        'style': 'clip-rule:evenodd;fill-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2'
    })

    # definições de gradientes
    # os ids definidos aqui são os que serão passados como argumentos pras outras funções auxiliares
    defs = ET.SubElement(svg, 'defs')
    
    front_fill = handle_fill(
        hex_map=hex_front, defs=defs, gradient_id='front-gradient',
        gradient_transform='matrix(2.54933e-15,-41.6338,41.6338,2.54933e-15,445.153,52.7218)'
    )
    back_fill = handle_fill(
        hex_map=hex_back, defs=defs,
        gradient_id='back-gradient',
        gradient_units='objectBoundingBox', # usa 0-100% do objeto. sem isso, o gradiente fica muito comprimido
        first_stop_offset=0.5,
        second_stop_offset=1
    )
    glyph_fill = handle_fill(
        hex_map=hex_glyph, defs=defs, gradient_id='glyph-gradient',
        gradient_transform=glyph_gradient_transform,
    )
    
    # grupos (<g> -> grupo)
    # o id deles é o equivalente ao nome que vai aparecer no inkscape
    #
    # desenhar de fato os elementos, usando sempre um diretório padrão como base
    # o glifo por cima do ícone de diretório só vai ser desenhado se ele tiver sido passado
    draw_directory(
        svg=svg,
        back_fill=back_fill,
        front_fill=front_fill
    )
    
    if glyph_d_contents is not None:
        draw_glyph(
            svg=svg,
            fill=glyph_fill,
            d_contents=glyph_d_contents,
            requires_scale=glyph_requires_scale,
            transform_value=glyph_transform_value,
            gradient_transform=glyph_gradient_transform
        )

    # indentar os conteúdos com x espaços, se não eles ficam todos numa linha só
    ET.indent(svg, space='  ', level=0)

    # converter pra string e escrever o xml gerado em um arquivo svg
    xml_str = ET.tostring(svg, encoding='utf-8', xml_declaration=True).decode('utf-8')
    with output_file.open('w') as f:
        f.write(xml_str)

def handle_palette(
    output_directory: Path,
    palette: dict,
    icon_name: str,
    glyph_d_contents: str | None = None,
    glyph_requires_scale: bool = False,
    glyph_transform_value: str = DEFAULT_TRANSFORM_VALUE,
    glyph_gradient_transform: str = DEFAULT_GLYPH_GRADIENT_TRANSFORM
    ):
    """
    a partir de uma paleta de cores, organiza os valores dela em variáveis e os normaliza
    depois, monta os dicts/mapas de possíveis gradientes

    se duas cores do mesmo tipo (ex: glyph_top e glyph_bottom) forem localizadas,
    e se as duas NÃO forem nulas, se assume que elas devam virar um gradiente,
    mas isso é responsabilidade da handle_fill, essa é só a definição dos mapas

    após isso, constrói o caminho final do arquivo, garantindo que os diretórios existam

    args:
        output_directory:
            diretório onde o arquivo svg deve ficar
        
        palette:
            um dicionário que contém múltiplas chaves específicas
            chaves essas que determinam cores dentro do arquivo
            ex: directory-bottom representa a cor mais escura do gradiente do ícone de diretório
        
        glyph_d_contents:
            os conteúdos dentro da propriedade 'd=' que os <path> têm
            isso é o que define a forma do path
        
        glyph_requires_scale:
            
    """

    # obter os valores do mapa
    # também junta todas elas num array depois pra ficar mais fácil de normalizar
    background = palette.get('background')
    background_secondary = palette.get('background-secondary')
    directory_top = palette.get('directory-top')
    directory_bottom = palette.get('directory-bottom')
    glyph_top = palette.get('glyph-top')
    glyph_bottom = palette.get('glyph-bottom')

    variables = [background, background_secondary, directory_top, directory_bottom, glyph_top, glyph_bottom]
    for v in variables:
        v = normalize_hex_value(v)

    # organizar as cores em dicts que a função de estruturação do svg entenda
    hex_front = { 'top': directory_top, 'bottom': directory_bottom }
    hex_back =  { 'top': background,    'bottom': background_secondary }
    hex_glyph = { 'top': glyph_top,     'bottom': glyph_bottom }

    # construir + normalizar o caminho final e gerar o svg
    output_directory.mkdir(parents=True, exist_ok=True)
    final = output_directory / icon_name
    final = normalized_svg_file(final)

    structure_svg(
        output_file=final,
        hex_front=hex_front,
        hex_back=hex_back,
        hex_glyph=hex_glyph,
        glyph_d_contents=glyph_d_contents,
        glyph_requires_scale=glyph_requires_scale,
        glyph_transform_value=glyph_transform_value,
        glyph_gradient_transform=glyph_gradient_transform
    )